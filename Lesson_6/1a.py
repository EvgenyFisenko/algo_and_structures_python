"""
1. Подсчитать, сколько было выделено памяти под переменные в ранее
разработанных программах в рамках первых трех уроков. Проанализировать
результат и определить программы с наиболее эффективным использованием памяти.
Примечание: Для анализа возьмите любые 1-3 ваших программы или несколько
вариантов кода для одной и той же задачи. Результаты анализа вставьте в виде
комментариев к коду. Также укажите в комментариях версию Python
и разрядность вашей ОС.
"""
from memory_profiler import profile
from pympler import asizeof


# @profile
def find_simple_num(ind):
    """
    O(N2)
    """
    lst = [2]
    i = 3
    while len(lst) < ind:
        for j in lst:
            if i % j == 0:
                break
        else:
            lst.append(i)
        i += 1
    # print(len(lst))
    # print(asizeof.asizeof(lst))  # 256 пятое простое число длина 5
    return lst[ind - 1]


# @profile
def eratosfen(num):
    """
    O(n log(log n))
    """
    lst = [0] * 10000
    for i in range(10000):
        lst[i] = i
    lst[1] = 0
    ind = 2
    while ind < 10000:
        if lst[ind] != 0:
            j = ind * 2
            while j < 10000:
                lst[j] = 0
                j = j + ind
        ind += 1
    fin_lst = [el for el in lst if el != 0]
    # print(asizeof.asizeof(lst))  # 119408 пятое простое число длина 10000
    # print(len(lst))
    # print(asizeof.asizeof(fin_lst))  # 49520 пятое простое число длина 1229
    # print(len(fin_lst))
    return fin_lst[num - 1]


print(find_simple_num(5))
print(eratosfen(5))

# print(find_simple_num(1000))
# print(eratosfen(1000))


# Python 3.8.0, windows 10, 64 bit
# Представленные алгоритмы ведут себя одинаково, как при поиске 5, так и 1000 простого числа.
# Однако стоит отметить, что представленная реализация решета все же немного проигрывает по памяти,
# как на 5, так и на 1000 числе, вызывая инкремент используемой памяти 0.1 MiB при заполнении списка
# нулями (lst = [0] * 10000) и 0.1 MiB при заполнении списка числами (for i in range(10000): lst[i] = i).
# Размер памяти, выделенной под переменные, при поиске 5 простого числа во втором алгоритме оказался
# значительно больше(119408 для списка длиной 10000 и 49520 для результирующего списка длиной 1229),
# чем в первом (256 для списка длиной 5).
